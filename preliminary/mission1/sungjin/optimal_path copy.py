import math

# 오프라인에서 계산된 최적 경로 (각 원소: [x, y, speed]).
# 실제로는 훨씬 세밀하고 많은 포인트가 필요합니다.
optimal_path = [[0.25792, 0.86332, 4.0],
                [0.11893, 1.01891, 4.0],
                [-0.01874, 1.17284, 4.0],
                [-0.17592, 1.34867, 4.0],
                [-0.34798, 1.54151, 4.0],
                [-0.52995, 1.74581, 4.0],
                [-0.71693, 1.95596, 3.52144],
                [-0.90987, 2.17318, 2.79514],
                [-1.10713, 2.39562, 2.38658],
                [-1.30725, 2.62167, 2.11603],
                [-1.50807, 2.84882, 1.91736],
                [-1.71407, 3.06774, 1.7643],
                [-1.93082, 3.26641, 1.64032],
                [-2.15977, 3.43268, 1.53467],
                [-2.39824, 3.55647, 1.53467],
                [-2.64036, 3.6311, 1.53467],
                [-2.87856, 3.65313, 1.53467],
                [-3.10433, 3.62144, 1.53467],
                [-3.30799, 3.53604, 1.53467],
                [-3.47701, 3.39788, 1.65822],
                [-3.60846, 3.22106, 1.73892],
                [-3.69878, 3.01409, 1.83066],
                [-3.74519, 2.78502, 1.93521],
                [-3.74606, 2.54219, 2.05935],
                [-3.7019, 2.29426, 2.18696],
                [-3.61578, 2.0495, 1.98047],
                [-3.49339, 1.81444, 1.98047],
                [-3.35534, 1.61048, 1.98047],
                [-3.23938, 1.40143, 1.98047],
                [-3.15121, 1.18537, 1.98047],
                [-3.09668, 0.9602, 1.98047],
                [-3.08407, 0.72346, 2.34848],
                [-3.10421, 0.47791, 2.63498],
                [-3.15394, 0.22462, 3.05529],
                [-3.22897, -0.03526, 3.6773],
                [-3.32398, -0.30049, 3.80452],
                [-3.43733, -0.58092, 2.94286],
                [-3.54544, -0.86345, 2.48315],
                [-3.64522, -1.14916, 2.18616],
                [-3.73331, -1.43894, 1.97504],
                [-3.80613, -1.73316, 1.81511],
                [-3.85984, -2.03156, 1.68502],
                [-3.88108, -2.33231, 1.57728],
                [-3.85793, -2.6263, 1.48638],
                [-3.78399, -2.89884, 1.40712],
                [-3.66094, -3.13421, 1.40712],
                [-3.49719, -3.32007, 1.40712],
                [-3.30424, -3.44861, 1.40712],
                [-3.09441, -3.51512, 1.40712],
                [-2.88048, -3.5158, 1.40712],
                [-2.6779, -3.44609, 1.57641],
                [-2.49625, -3.32139, 1.72646],
                [-2.34124, -3.15005, 1.92392],
                [-2.21599, -2.93972, 2.20724],
                [-2.12037, -2.69858, 2.02637],
                [-2.04981, -2.43574, 1.78172],
                [-1.99508, -2.16083, 1.60383],
                [-1.93263, -1.88489, 1.47009],
                [-1.84975, -1.62521, 1.36168],
                [-1.7377, -1.39302, 1.36168],
                [-1.59372, -1.19856, 1.36168],
                [-1.42019, -1.0509, 1.36168],
                [-1.22334, -0.95879, 1.36168],
                [-1.01343, -0.93121, 1.36168],
                [-0.80729, -0.97786, 1.49994],
                [-0.61965, -1.08431, 1.61331],
                [-0.45969, -1.24165, 1.75187],
                [-0.33377, -1.44167, 1.92991],
                [-0.2455, -1.67602, 1.83366],
                [-0.19492, -1.93596, 1.50247],
                [-0.1775, -2.21285, 1.3],
                [-0.18417, -2.49917, 1.3],
                [-0.19965, -2.75653, 1.3],
                [-0.18606, -2.99663, 1.3],
                [-0.12847, -3.2071, 1.3],
                [-0.02244, -3.37836, 1.3],
                [0.13308, -3.49719, 1.38569],
                [0.32489, -3.56319, 1.66601],
                [0.5401, -3.58442, 1.96655],
                [0.77185, -3.56568, 2.44337],
                [1.01401, -3.51545, 2.86799],
                [1.26577, -3.48745, 2.61789],
                [1.51687, -3.48155, 2.16026],
                [1.76715, -3.49571, 1.88052],
                [2.01654, -3.52832, 1.6859],
                [2.26497, -3.578, 1.54037],
                [2.51115, -3.64316, 1.42374],
                [2.75413, -3.67895, 1.42374],
                [2.98477, -3.6764, 1.42374],
                [3.19678, -3.63205, 1.42374],
                [3.38448, -3.54454, 1.42374],
                [3.54025, -3.41222, 1.42374],
                [3.65044, -3.23239, 1.54918],
                [3.71023, -3.01561, 1.64974],
                [3.71084, -2.77068, 1.77023],
                [3.64508, -2.51257, 1.91947],
                [3.51617, -2.26397, 2.10838],
                [3.33898, -2.04219, 2.3651],
                [3.12846, -1.85, 2.74182],
                [2.89518, -1.68254, 3.36852],
                [2.6409, -1.52898, 3.59073],
                [2.39794, -1.35761, 3.86154],
                [2.16532, -1.17111, 4.0],
                [1.94187, -0.97199, 4.0],
                [1.72626, -0.76268, 4.0],
                [1.51698, -0.54555, 4.0],
                [1.31238, -0.32295, 4.0],
                [1.11068, -0.09712, 4.0],
                [0.91754, 0.1212, 4.0],
                [0.73441, 0.32779, 4.0],
                [0.56319, 0.52056, 4.0],
                [0.40447, 0.69893, 4.0]]

def reward_function(params):
    """
    1Lap 주행을 전제로:
      1) 최적 코스와의 거리(min_distance) 최소화
      2) 최적 속도와의 오차 최소화
      3) 코너 구간에서 heading 보정(필요 시)
      4) 진행도(progress) 보상 (0~100)
      5) 트랙 이탈 방지, 스티어링 안정성
    """

    ################################################################################
    # 1. 파라미터 로드
    ################################################################################
    x = params['x']
    y = params['y']
    speed = params['speed']
    heading = params['heading']               # 현재 차량의 진행 방향 (degrees)
    all_wheels_on_track = params['all_wheels_on_track']
    progress = params['progress']             # 0~100
    steering_angle = abs(params['steering_angle'])  # 좌우 상관없이 절대값 사용

    ################################################################################
    # 2. 기본 보상 초기화 & 트랙 이탈 체크
    ################################################################################
    # 기본 보상값
    reward = 1.0

    # 바퀴가 트랙 밖으로 나가면 즉시 최소 보상
    # if not all_wheels_on_track:
    #     return 1e-3

    ################################################################################
    # 3. 최적 코스에서 가장 가까운 지점 찾기
    ################################################################################
    def euclidean_distance(x1, y1, x2, y2):
        return math.sqrt((x1 - x2)**2 + (y1 - y2)**2)

    min_distance = float('inf')
    closest_index = 0
    for i, (opt_x, opt_y, opt_spd) in enumerate(optimal_path):
        dist = euclidean_distance(x, y, opt_x, opt_y)
        if dist < min_distance:
            min_distance = dist
            closest_index = i

    # 이론적으로 계산된 최적 속도
    theoretical_speed = optimal_path[closest_index][2]

    ################################################################################
    # 4. "최적 코스" 거리 보상 (Exponential)
    ################################################################################
    distance_multiplier = 8.0
    distance_factor = math.exp(-distance_multiplier * min_distance)  
    reward *= distance_factor

    ################################################################################
    # 5. 최적 속도 보상 (물리 한계를 고려한 클램핑)
    ################################################################################

    # 실제 차량이 낼 수 있는 최대 속도 (예: 트랙/세팅 상 3.5m/s 정도)
    # 값은 실험적으로 파악하거나 환경 세팅에 따라 다를 수 있음.
    MAX_FEASIBLE_SPEED = 3.5  

    # recommended_speed가 물리적으로 불가능한 수준이면 일단 MAX_FEASIBLE_SPEED로 클램핑
    clamped_speed = min(theoretical_speed, MAX_FEASIBLE_SPEED)

    # 속도 차이 계산
    speed_diff = abs(clamped_speed - speed)

    # diff=0일 때 보상 1, diff=2이상은 1e-3 등 (선형 예시)
    speed_tolerance = 1.25
    speed_factor = 1.0 - (speed_diff / speed_tolerance)
    if speed_factor < 0:
        speed_factor = 1e-3

    reward *= speed_factor

    ################################################################################
    # 6. (선택) 코너 각도 & Heading 보정
    ################################################################################
    # - 최적 경로의 다음 지점과 현재 지점을 이용해 "최적 경로 방향"을 추정하고,
    #   차량 heading과 비교 → 차이가 작을수록 보상
    heading_factor = 1.0

    # next index 계산 (closest_index+1, 범위 넘어가면 마지막 혹은 유지)
    next_index = min(closest_index + 1, len(optimal_path) - 1)
    dx = optimal_path[next_index][0] - optimal_path[closest_index][0]
    dy = optimal_path[next_index][1] - optimal_path[closest_index][1]

    # 최적경로 상의 진행 방향(각도)
    optimal_heading = math.degrees(math.atan2(dy, dx))

    # 차량 heading과 최적경로 heading 차이 (절대값)
    heading_diff = abs(optimal_heading - heading)
    if heading_diff > 180:
        heading_diff = 360 - heading_diff

    # 0도 차이=1.0, 30도 이상 차이=1e-3까지 낮춤 (선형 예시)
    if heading_diff <= 5:
        heading_factor = 1.0
    elif heading_diff <= 30:
        heading_factor = 1.0 - (heading_diff / 30.0)  # 5도~30도 사이 선형 감소
    else:
        heading_factor = 1e-3

    reward *= heading_factor

    ################################################################################
    # 7. 스티어링 안정성 페널티
    ################################################################################
    # 지나치게 큰 조향 각도(steering_angle)면 살짝 페널티
    # STEERING_THRESHOLD = 25.0
    # if steering_angle > STEERING_THRESHOLD:
    #     reward *= 0.8  # 조금 깎음

    ################################################################################
    # 8. 진행도(progress)에 대한 보상
    ################################################################################
    # - 1Lap: progress는 0~100
    # - 간단히 progress/100을 곱해 보상 스케일을 조정
    base_progress_factor = 1.0 + (progress / 100.0)
    reward *= base_progress_factor

    # (선택) 완주 보너스: progress >= 100일 경우
    if progress >= 100:
        reward += 10.0

    ################################################################################
    # 최종 반환
    ################################################################################
    return float(reward)
